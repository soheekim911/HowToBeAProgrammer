# 성능 문제를 이해하는 법
[//]: # (Version:1.0.0)
디버깅을 배우는 것처럼 실행 중인 시스템의 성능을 이해하는 법을 배우는 것은 피할 수 없는 일입니다. 설령 당신이 쓴 코드의 비용을 완벽하게 정확히 이해하고 있다고 하더라도, 그 코드는 당신에게 통제권이나 가시성이 거의 없는 소프트웨어 시스템을 호출할 것입니다. 그러나, 현실에서 성능 문제는 일반적인 디버깅과 조금 다르고 조금 더 쉽습니다.

당신이나 당신의 고객이 시스템이나 하부시스템이 너무 느리다고 생각한다고 가정해 봅시다. 그걸 더 빠르게 하기 전에, 왜 그것이 느린지에 대한 정신적 모델(mental model)을 세워야만 합니다. 이를 위해 프로파일링 도구나 잘 기록된 로그를 사용해서 시간이나 다른 리소스가 실제로 어디에 사용되고 있는지를 찾아낼 수 있습니다. 10%의 코드가 90%의 시간을 잡아먹는다는 유명한 격언이 있습니다. 저는 여기에 성능 문제에 대한 입출력 비용(I/O)의 중요성을 첨언하겠습니다. 대개 대부분의 시간은 어떤 식으로든 I/O에 사용됩니다. 값비싼 I/O나 10%의 비용이 많이 드는 코드를 찾아내는 것은 정신적 모델을 만드는 좋은 첫걸음입니다. 

컴퓨터 시스템의 성능에는 많은 차원이 존재하며, 많은 종류의 리소스가 소비됩니다. 측정해야 하는 첫 번째 리소스는 *wall-clock time(벽시계 시간)*, 즉 계산하는 데에 걸리는 총 시간입니다. *wall-clock time*을 로깅 하는 것은 다른 프로파일링을 실행할 수 없을 때 발생하는 예측불가능한 상황에 대해 알려준다는 점에서 특히 귀중합니다. 하지만, 이것이 항상 모든 것을 알려주지는 않습니다. 때로 당신이 실제로 접할 컴퓨팅 환경에서 시간은 조금 더 걸리지만 프로세서를 많이 소모하지 않는 쪽이 훨씬 나을 수도 있습니다. 비슷하게, 메모리, 네트워크 대역폭, 데이터베이스 혹은 다른 서버 접근이 결론적으로는 프로세서 사용량보다 훨씬 비용이 많이 들 수도 있습니다.

동기화된 공유 리소스에 대한 경합은 교착 상태나 결핍을 만들어낼 수도 있습니다. 교착 상태(Deadlock)는 부적절한 동기화나 리소스 요구 때문에 진행이 불가능해지는 것입니다. 결핍(Starvation)은 구성요소를 적절하게 계획하는 데에 실패하는 것입니다. 이 모든 것이 예상 가능하다면, 프로젝트를 시작할 때부터 이러한 경합을 측정하는 방법을 두는 것이 최선입니다. 경합이 일어나지 않더라도, 확신을 가지고 이를 가정할 수 있다는 점에서 매우 유익합니다. 

다음 장 [성능 문제를 해결하는 법](06-How-to-Fix-Performance-Problems.md)
